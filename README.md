# 档案存储服务（Archives）

这是一个通用的存档服务，存储的目标为任意类型的数据文档。

对这些文档的检索仅以其内容的哈希摘要为索引（文档ID），这可以方便存档者构建其检索索引。当前采用 `SHA3:Sum256` 摘要算法。

> **注：**
> 区块链交易里的附件也存储于此，因为这些附件并不存储在区块链上（交易里只有一个ID）。

本实现采用本地文件系统作为其存档框架。


## 文档元信息

文档的基本信息存储在其关联的 .meta 文件中，包含对文档的基础性描述。如文档类型、概要、大小、时间戳等。内容条目并不固定，这与文档自身的类型有关。

### 共有字段

- 类型：MIME 类型，如：image/svg+xml
- 标题：文档的名称。
- 概要：文档的内容摘要、大纲。
- 上传者：不一定是作者。
- 上传时间：当前保存文档的时间。
- 大小：文档大小（字节数），通常自动计算。
- 语言：文档内容所属的语种（主要语言）。可选。
- 作者：文档的原始作者，多位并列，分号分隔。可选。
- 版权：文档的原版权声明。可选。
- 创建时间：文档原始创建时的时间。可选。

> **注：**
> 类型可参考 HTML 的 MIME 定义。


### 文件名规则：

```go
[文档ID]/文档ID[0:16].data       // 文档数据
[文档ID]/文档ID[0:16].meta       // 文档元信息，文本格式。这是默认语言版本
[文档ID]/文档ID[0:16].meta.zh_cn // 元信息的简体中文版
```

> **注：**
> 方括号仅为可变示意，文件名并不包含方括号本身。

其它语言版本的 meta 可以单独上传，但需先保存返回的文档ID（`SHA3:Sum256`）。

### 存档路径：

四层结构，首层为文档创建年度，其次为文档ID的*逐字节*分层，前置层级数。

目录结构/文件名示意如下：

```go
2025/                                       // 年度（存档时间）
    [DID:0xff]/                             // 一级：文档ID首字节16进制表达，小写
        [DID:FF]/                           // 二级：次字节16进制表达，大写，无前置0x
            [DID:255]/                      // 三级：第三字节16进制表达，3位十进制
                [DID]/DID[0:16].data        // 文档数据
                [DID]/DID[0:16].meta        // 文档元信息文件，可能有多个语言的版本
                [DID]/DID[0:16].meta.en_us  // 特定语言版本的元信息，可选
```

> #### 关于年度设计
> 顶层年度分级，一是可以分流，二是让数据拥有明确的历史性，同时也便于管理。
> 比如出于安全原因，需要更新久远古代数据的哈希 ^_*..
>
> 如果用户知道文档的年代，可以直接获取，否则就需要一个上层逻辑：由ID对应文档的存档时间了。


## 固化存储

档案的逻辑是不可修改，只能写入和检索读取，甚至删除都不应该有（覆写没有意义，因为ID相同表示内容也相同），通常也是长期保存。

因此对于档案存储，我们可以简化设计：

1. 仅包含读取和添加两种逻辑，没有修改和删除的操作。
2. 缩小存档规模仅能通过转储实现：读取 >> 过滤 >> 添加到新仓库。
3. 没有删除是档案逻辑，从外部创建一种「不方便」的阻碍。

因为没有修改和删除，这类似于一种固化存储（只读），它能带来一些优点：

- 便于优化存档，提高数据库效率。
- 仅单次写入的优势可能发展出廉价的存储介质，使得大规模存档更易行。
- 安全性更有保障。除非物理上的破坏，不存在数据误操作的问题。
- 因为简单，维护的成本也应该表现不错。
