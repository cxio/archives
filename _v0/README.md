# 档案存储服务（Archives）

这是一个通用的存档服务，存储的目标为任意类型的数据文档。

因为是通用存档，所以文档的大小是任意的。为了规范对任意大小文档的检索，这里设计了一些约束（协议）：

- 对文档的检索仅以其**数据ID**为索引。数据ID为分片哈希合并后的哈希，仅一级合并（平级，非树结构）。
- 分片大小固定为**2GB**，末段分片不足**10%**（200MB）时放弃切分。即最后一个分片可能大于2GB，但不会超过2.2GB。
- 这是存档分片，不是网络传输的数据分片（如`BitTorrent`）。
- 每个分片数据的哈希摘要（`SHA3:Sum256`）串联合并后计算总的哈希，即为数据ID。

> **注：**
> 区块链交易里的附件也存储于此，因为这些附件并不存储在区块链上（交易里只有一个ID）。

这里采用本地文件系统作为存档框架，提供服务。

它是数据驿站（depots）的内部子服务，与用户交互的是独立的P2P分发客户端，客户端向内与此档案存储系统连接，因此2GB的分片大小是可行的。


## 文档元信息

文档的基本信息存储在其关联的`.meta`文件中，包含对文档的各种描述。如：类型、概要、大小、时间戳等。内容条目并不完全固定，这与文档自身的类型有关。

### 共有字段

- 类型：MIME 类型，如：image/svg+xml
- 标题：文档的名称。
- 概要：文档的内容摘要、大纲。
- 上传者：不一定是作者。
- 上传时间：当前保存文档的时间。
- 大小：文档大小（字节数），通常自动计算。
- 语言：文档内容所属的语种（主要语言）。可选。
- 作者：文档的原始作者，多位并列，分号分隔。可选。
- 版权：文档的原版权声明。可选。
- 创建时间：文档原始创建时的时间。可选。

> **注**：类型参考 HTML 的 MIME 定义。


### 文件名规则：

约定：数据ID简称为 `DID`，分片ID为 `PID`。

```go
// 上级目录
DID/        // 具体存档目录，完整DID目录名

// 文档ID前8字节命名（16个十六进制字符），
DID[0:8].meta           // 文档元信息，文本格式。这是默认语言版本
DID[0:8].meta.zh_cn     // 元信息的多语言版本（简体中文）

// 文档数据序列
// 取分片ID前16字节命名（32个十六进制字符），前置分片序号（从0开始）
0.PID[0:16].data
1.PID[0:16].data
...

// 非分片数据
DID[0:16].data      // 文档小于2.2GB时无分片。
```

> **注**：非默认的多语言版本的 meta 可以单独上传。


### 存档路径：

四层结构，首层为文档的存档年度，其次为数据ID的*逐字节*分层。

目录结构/文件名示意如下：

```go
2025/                                       // 年度（存档时间）
    [DID:0xff]/                             // 一级：文档ID首字节16进制表达，小写
        [DID:FF]/                           // 二级：次字节16进制表达，大写，无前置0x
            [DID:255]/                      // 三级：第三字节16进制表达，3位十进制
                [DID]/                      // 存档目录
                    0.PID[0:16].data        // 分片1
                    1.PID[0:16].data        // 分片2
                    ...
                    DID[0:8].meta           // 文档元信息，默认语言的版本
                    DID[0:8].meta.en_us     // 其它语言版本，可选
                    chunks.list             // 分片哈希序列。按行有序罗列，十六进制文本（审阅友好）
                                            // 如果文档无需分片，则无此文件
```

> #### 关于年度设计
> 顶层年度分级，一是可以分流，二是让数据拥有明确的历史性，同时也便于管理。
> 比如出于安全原因，需要更新久远古代数据的哈希 ^_*..
>
> 如果用户知道文档的年代，可以直接获取，否则就需要一个上层逻辑：由ID对应文档的存档时间了。


## 固化存储

档案的逻辑是不可修改，只能写入和检索读取，甚至删除都不应该有（覆写没有意义，因为ID相同表示内容也相同），通常也是长期保存。

因此对于档案存储，我们可以简化设计：

1. 仅包含读取和添加两种逻辑，没有修改和删除的操作。
2. 缩小存档规模仅能通过转储实现：读取 >> 过滤 >> 添加到新仓库。
3. 没有删除是档案逻辑，从外部创建一种「不方便」的阻碍。

因为没有修改和删除，这类似于一种固化存储（只读），它能带来一些优点：

- 便于优化存档，提高数据库效率。
- 仅单次写入的优势可能发展出廉价的存储介质，使得大规模存档更易行。
- 安全性更有保障。除非物理上的破坏，不存在数据误操作的问题。
- 因为简单，维护的成本也应该表现不错。
